<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Realistic Market Simulation Dashboard</title>

<!-- Chart.js and Financial plugin -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>

<style>
/* ===== Reset & Global Styles ===== */
*{margin:0;padding:0;box-sizing:border-box;font-family:'Segoe UI',sans-serif;}
body{background:linear-gradient(to right,#0f2027,#203a43,#2c5364);color:#fff;overflow-x:hidden;transition:0.5s;}
.light-mode{background:linear-gradient(to right,#a8edea,#fed6e3);color:#333;}
.dark-mode{background:linear-gradient(to right,#0f2027,#203a43,#2c5364);color:#fff;}
canvas{display:block;margin:auto;}
header{text-align:center;padding:40px 20px;}
header h1{font-size:3rem;margin-bottom:10px;}
header p{font-size:1.2rem;color:#ccc;}
#controls{text-align:center;margin:20px;}
select, button, input[type=range]{padding:8px 15px;margin:0 10px;border:none;border-radius:5px;font-size:1rem;cursor:pointer;transition:0.3s;}
select:hover, button:hover, input[type=range]:hover{transform:scale(1.05);}
#charts{display:flex;flex-wrap:wrap;justify-content:center;gap:30px;padding:20px;}
.chart-container{background:rgba(255,255,255,0.05);padding:20px;border-radius:20px;box-shadow:0 8px 20px rgba(0,0,0,0.3);transition:transform 0.3s;}
.chart-container:hover{transform:scale(1.02);}
.chart-desc{text-align:center;margin-top:10px;font-weight:bold;color:#ccc;}
#info{display:flex;flex-wrap:wrap;justify-content:center;gap:20px;padding:40px 20px;}
.info-card{background:rgba(255,255,255,0.05);padding:20px;border-radius:20px;width:300px;box-shadow:0 8px 20px rgba(0,0,0,0.3);transition:transform 0.3s;}
.info-card:hover{transform:translateY(-10px);}
.info-card h2{margin-bottom:10px;color:#4caf50;}
footer{text-align:center;padding:20px;color:#ccc;}
#bgCanvas{position:fixed;top:0;left:0;width:100%;height:100%;z-index:-1;}
</style>
</head>
<body class="dark-mode">

<canvas id="bgCanvas"></canvas>

<header>
<h1>Market Simulation Dashboard</h1>
<p>Interactive candlestick, heatmap, volume, and trend charts with realistic simulated data</p>
</header>

<section id="controls">
<label for="dataset">Select Market:</label>
<select id="dataset">
<option value="1">Simulated Stock A</option>
<option value="2">Simulated Stock B</option>
<option value="3">Simulated Stock C</option>
</select>
<label for="speed">Animation Speed:</label>
<input type="range" id="speed" min="50" max="1000" value="300">
<button id="mode">Toggle Dark/Light</button>
</section>

<section id="charts">
<div class="chart-container">
<canvas id="candlestickChart"></canvas>
<p class="chart-desc">Candlestick Chart</p>
</div>

<div class="chart-container">
<canvas id="volumeChart"></canvas>
<p class="chart-desc">Volume Chart</p>
</div>

<div class="chart-container">
<canvas id="heatmapChart"></canvas>
<p class="chart-desc">Heatmap / Liquidity</p>
</div>

<div class="chart-container">
<canvas id="trendChart"></canvas>
<p class="chart-desc">Trend Line Chart</p>
</div>
</section>

<section id="info">
<div class="info-card">
<h2>Interactive Exploration</h2>
<p>Hover over charts for detailed info, adjust animation speed, and switch datasets.</p>
</div>
<div class="info-card">
<h2>Dynamic Updates</h2>
<p>Charts animate with realistic market-like fluctuations. Heatmap and volume bars respond accordingly.</p>
</div>
<div class="info-card">
<h2>Visual Psychology</h2>
<p>Gradients, smooth animations, and particle backgrounds help guide attention and engagement.</p>
</div>
</section>

<footer>Fully front-end, interactive, and realistic market simulation dashboard</footer>

<script>
// ====================== PARTICLE BACKGROUND ======================
const canvas = document.getElementById('bgCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const particles=[];
const colors=['#4caf50','#81c784','#388e3c','#2e7d32'];
for(let i=0;i<200;i++){
    particles.push({
        x:Math.random()*canvas.width,
        y:Math.random()*canvas.height,
        radius:Math.random()*2+1,
        dx:(Math.random()-0.5)*0.5,
        dy:(Math.random()-0.5)*0.5,
        color:colors[Math.floor(Math.random()*colors.length)]
    });
}
function animateParticles(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    particles.forEach(p=>{
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);
        ctx.fillStyle=p.color;
        ctx.fill();
        p.x+=p.dx;
        p.y+=p.dy;
        if(p.x<0||p.x>canvas.width)p.dx*=-1;
        if(p.y<0||p.y>canvas.height)p.dy*=-1;
    });
    requestAnimationFrame(animateParticles);
}
animateParticles();
window.addEventListener('resize',()=>{
    canvas.width=window.innerWidth;
    canvas.height=window.innerHeight;
});
</script>

</body>
</html>

<script>
// ====================== DATA SIMULATION ENGINE ======================

// Function to generate realistic candlestick data
function generateCandlestickData(days=50, startPrice=100){
    const data=[];
    let price=startPrice;
    for(let i=0;i<days;i++){
        const open=price;
        const change=(Math.random()-0.5)*5; // small random daily change
        const close=open+change;
        const high=Math.max(open,close)+Math.random()*3;
        const low=Math.min(open,close)-Math.random()*3;
        data.push({x:i,o:parseFloat(open.toFixed(2)),h:parseFloat(high.toFixed(2)),l:parseFloat(low.toFixed(2)),c:parseFloat(close.toFixed(2))});
        price=close;
    }
    return data;
}

// Function to generate realistic volume data based on candlestick changes
function generateVolumeData(candles){
    return candles.map(c=>{
        const base=50;
        const range=Math.abs(c.c - c.o)*50;
        return Math.round(base + range + Math.random()*50);
    });
}

// Function to generate trend line data (e.g., moving average)
function generateTrendData(candles){
    let trend=50;
    return candles.map(c=>{
        trend += (Math.random()-0.5)*5;
        return parseFloat(trend.toFixed(2));
    });
}

// Function to generate heatmap / liquidity data
function generateHeatmapData(candles){
    return candles.map(c=>Math.floor(Math.random()*100));
}

// ====================== INITIAL DATA ======================
let datasets = {
1: {candles: generateCandlestickData(), volume:[], trend:[], heatmap:[]},
2: {candles: generateCandlestickData(60,120), volume:[], trend:[], heatmap:[]},
3: {candles: generateCandlestickData(70,90), volume:[], trend:[], heatmap:[]}
};

for(let key in datasets){
    datasets[key].volume = generateVolumeData(datasets[key].candles);
    datasets[key].trend = generateTrendData(datasets[key].candles);
    datasets[key].heatmap = generateHeatmapData(datasets[key].candles);
}

// ====================== CHART INITIALIZATION ======================
const ctxCandle=document.getElementById('candlestickChart').getContext('2d');
let candlestickChart = new Chart(ctxCandle,{
    type:'candlestick',
    data:{datasets:[{label:'Candlestick',data:datasets[1].candles}]},
    options:{
        responsive:true,
        animation:{duration:0},
        plugins:{tooltip:{enabled:true}}
    }
});

const ctxVolume=document.getElementById('volumeChart').getContext('2d');
let volumeChart = new Chart(ctxVolume,{
    type:'bar',
    data:{
        labels:datasets[1].candles.map((c,i)=>i),
        datasets:[{label:'Volume',data:datasets[1].volume,backgroundColor:'rgba(255,206,86,0.6)'}]
    },
    options:{responsive:true,animation:{duration:0}}
});

const ctxTrend=document.getElementById('trendChart').getContext('2d');
let trendChart = new Chart(ctxTrend,{
    type:'line',
    data:{
        labels:datasets[1].candles.map((c,i)=>i),
        datasets:[{label:'Trend',data:datasets[1].trend,borderColor:'rgba(54,162,235,0.8)',backgroundColor:'rgba(54,162,235,0.2)',fill:true,tension:0.4}]
    },
    options:{responsive:true,animation:{duration:0}}
});

const ctxHeat=document.getElementById('heatmapChart').getContext('2d');
let heatmapChart = new Chart(ctxHeat,{
    type:'bar',
    data:{
        labels:datasets[1].candles.map((c,i)=>i),
        datasets:[{label:'Heatmap',data:datasets[1].heatmap,backgroundColor:datasets[1].heatmap.map(v=>'rgba(255,99,132,'+v/100+')')}]
    },
    options:{responsive:true,animation:{duration:0}}
});
</script>

<script>
// ====================== INTERACTIVITY & ANIMATION ======================

let currentDataset = 1;
let speed = parseInt(document.getElementById('speed').value);
let tick = 0;

// Update charts instantly when switching datasets
function updateChartsInstant(){
    const data = datasets[currentDataset];
    candlestickChart.data.datasets[0].data = data.candles;
    candlestickChart.update('none');

    volumeChart.data.datasets[0].data = data.volume;
    volumeChart.update('none');

    trendChart.data.datasets[0].data = data.trend;
    trendChart.update('none');

    heatmapChart.data.datasets[0].data = data.heatmap;
    heatmapChart.data.datasets[0].backgroundColor = data.heatmap.map(v=>'rgba(255,99,132,'+v/100+')');
    heatmapChart.update('none');
}

// Animate charts over time like live market
function animateCharts(){
    const data = datasets[currentDataset];
    const len = data.candles.length;
    const index = tick % len;

    // Update candlestick chart
    candlestickChart.data.datasets[0].data = data.candles.slice(0,index+1);
    candlestickChart.update('none');

    // Update volume chart
    volumeChart.data.datasets[0].data = data.volume.slice(0,index+1);
    volumeChart.update('none');

    // Update trend chart
    trendChart.data.datasets[0].data = data.trend.slice(0,index+1);
    trendChart.update('none');

    // Update heatmap chart
    heatmapChart.data.datasets[0].data = data.heatmap.slice(0,index+1);
    heatmapChart.data.datasets[0].backgroundColor = data.heatmap.slice(0,index+1).map(v=>'rgba(255,99,132,'+v/100+')');
    heatmapChart.update('none');

    tick++;
    setTimeout(animateCharts, speed);
}

// ====================== EVENT LISTENERS ======================

// Dataset switcher
document.getElementById('dataset').addEventListener('change', function(){
    currentDataset = parseInt(this.value);
    tick = 0; // reset animation
    updateChartsInstant();
});

// Animation speed control
document.getElementById('speed').addEventListener('input', function(){
    speed = parseInt(this.value);
});

// Light/Dark mode toggle
document.getElementById('mode').addEventListener('click', ()=>{
    document.body.classList.toggle('dark-mode');
    document.body.classList.toggle('light-mode');
});

// Start animation
animateCharts();
</script>

<script>
// ====================== ADVANCED PARTICLE & GRADIENT INTERACTIONS ======================

const mouse = { x: null, y: null };
window.addEventListener('mousemove', e => { mouse.x = e.x; mouse.y = e.y; });

// Add extra particle layers for depth
const extraParticles = [];
const extraColors = ['#ff9800','#ffc107','#ff5722','#ff7043'];
for(let i=0;i<100;i++){
    extraParticles.push({
        x:Math.random()*canvas.width,
        y:Math.random()*canvas.height,
        radius:Math.random()*2+0.5,
        dx:(Math.random()-0.5)*1,
        dy:(Math.random()-0.5)*1,
        color:extraColors[Math.floor(Math.random()*extraColors.length)]
    });
}

function animateExtraParticles(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Draw main particles
    particles.forEach(p=>{
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);
        ctx.fillStyle=p.color;
        ctx.fill();
        p.x += p.dx;
        p.y += p.dy;
        if(p.x<0||p.x>canvas.width)p.dx*=-1;
        if(p.y<0||p.y>canvas.height)p.dy*=-1;
    });

    // Draw extra particles with mouse attraction
    extraParticles.forEach(p=>{
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);
        ctx.fillStyle=p.color;
        ctx.fill();

        // Move towards mouse slightly
        if(mouse.x && mouse.y){
            p.x += (mouse.x - p.x) * 0.002;
            p.y += (mouse.y - p.y) * 0.002;
        }

        p.x += p.dx;
        p.y += p.dy;
        if(p.x<0||p.x>canvas.width)p.dx*=-1;
        if(p.y<0||p.y>canvas.height)p.dy*=-1;
    });

    // Gradient overlay
    const gradient = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
    gradient.addColorStop(0,'rgba(0,0,0,0.1)');
    gradient.addColorStop(0.5,'rgba(255,255,255,0.05)');
    gradient.addColorStop(1,'rgba(0,0,0,0.1)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    requestAnimationFrame(animateExtraParticles);
}
animateExtraParticles();

// ====================== COMBINED CANDLESTICK + VOLUME CHART ======================

const combinedCtx = document.createElement('canvas');
combinedCtx.id = 'combinedChart';
combinedCtx.width = 800;
combinedCtx.height = 400;
combinedCtx.style.display = 'block';
combinedCtx.style.margin = '40px auto';
document.body.insertBefore(combinedCtx, document.getElementById('info'));

const ctxCombined = combinedCtx.getContext('2d');
let combinedChart = new Chart(ctxCombined, {
    type: 'candlestick',
    data: {
        datasets: [
            { label: 'Candlestick', data: datasets[1].candles, yAxisID:'yPrice' },
            { type: 'bar', label: 'Volume', data: datasets[1].volume, yAxisID:'yVolume', backgroundColor:'rgba(255,206,86,0.5)' }
        ]
    },
    options: {
        responsive:true,
        animation:{duration:0},
        scales:{
            yPrice:{type:'linear',position:'left'},
            yVolume:{type:'linear',position:'right',grid:{display:false}}
        },
        plugins:{tooltip:{enabled:true}}
    }
});

// ====================== MULTI-LAYER HEATMAP ======================

const heatmapLayers = [];
for(let l=0;l<3;l++){
    heatmapLayers.push(datasets[1].heatmap.map(v=>v*(Math.random()*0.5 + 0.5)));
}

function animateHeatmapLayers(){
    const ctx = document.getElementById('heatmapChart').getContext('2d');
    const combinedData = heatmapLayers.map(layer=>layer.map((v,i)=>v + Math.random()*5 - 2));
    heatmapChart.data.datasets[0].data = combinedData[0].map((v,i)=>v + combinedData[1][i] + combinedData[2][i]);
    heatmapChart.data.datasets[0].backgroundColor = heatmapChart.data.datasets[0].data.map(v=>'rgba(255,0,0,'+Math.min(v/100,1)+')');
    heatmapChart.update('none');
    requestAnimationFrame(animateHeatmapLayers);
}
animateHeatmapLayers();

// ====================== INFO CARD ANIMATION ======================

const infoCards = document.querySelectorAll('.info-card');
infoCards.forEach(card=>{
    card.addEventListener('mouseover',()=>{
        card.style.transform='translateY(-15px) scale(1.05)';
        card.style.boxShadow='0 12px 25px rgba(0,0,0,0.5)';
    });
    card.addEventListener('mouseout',()=>{
        card.style.transform='translateY(0) scale(1)';
        card.style.boxShadow='0 8px 20px rgba(0,0,0,0.3)';
    });
});

// ====================== WINDOW RESIZE ADJUSTMENTS ======================

window.addEventListener('resize',()=>{
    combinedChart.resize();
    candlestickChart.resize();
    volumeChart.resize();
    trendChart.resize();
    heatmapChart.resize();
});
</script>
<script>
// ====================== TOOLTIP & HOVER ANIMATIONS ======================

// Enhance candlestick chart tooltips with extra info
candlestickChart.options.plugins.tooltip.callbacks = {
    label: function(context) {
        const c = context.raw;
        return `O: ${c.o} H: ${c.h} L: ${c.l} C: ${c.c}`;
    }
};
candlestickChart.update();

// Enhance volume chart tooltips
volumeChart.options.plugins.tooltip.callbacks = {
    label: function(context){
        return `Volume: ${context.raw}`;
    }
};
volumeChart.update();

// Enhance trend chart tooltips
trendChart.options.plugins.tooltip.callbacks = {
    label: function(context){
        return `Trend: ${context.raw}`;
    }
};
trendChart.update();

// Enhance heatmap chart tooltips
heatmapChart.options.plugins.tooltip.callbacks = {
    label: function(context){
        return `Liquidity: ${context.raw}`;
    }
};
heatmapChart.update();

// ====================== TIMELINE SLIDERS PER CHART ======================

function createSlider(chart, containerId){
    const slider = document.createElement('input');
    slider.type='range';
    slider.min=0;
    slider.max=datasets[currentDataset].candles.length-1;
    slider.value=datasets[currentDataset].candles.length-1;
    slider.style.width='80%';
    slider.style.margin='10px auto';
    slider.addEventListener('input', ()=>{
        const idx = parseInt(slider.value);
        chart.data.datasets[0].data = datasets[currentDataset].candles.slice(0,idx+1);
        chart.update('none');
    });
    document.getElementById(containerId).appendChild(slider);
}

// Create sliders under each chart
createSlider(candlestickChart,'charts');
createSlider(volumeChart,'charts');
createSlider(trendChart,'charts');
createSlider(heatmapChart,'charts');

// ====================== DYNAMIC EASING FOR CANDLESTICKS & TREND ======================

function easeUpdateChart(chart,data,step=0.1){
    const currentData = chart.data.datasets[0].data;
    for(let i=0;i<data.length;i++){
        if(typeof data[i] === 'object'){ // candlestick
            currentData[i] = {
                o: currentData[i] ? currentData[i].o + (data[i].o - currentData[i].o)*step : data[i].o,
                h: currentData[i] ? currentData[i].h + (data[i].h - currentData[i].h)*step : data[i].h,
                l: currentData[i] ? currentData[i].l + (data[i].l - currentData[i].l)*step : data[i].l,
                c: currentData[i] ? currentData[i].c + (data[i].c - currentData[i].c)*step : data[i].c,
                x: i
            };
        } else { // trend or volume
            currentData[i] = currentData[i] + (data[i]-currentData[i])*step;
        }
    }
    chart.update('none');
}

function animateWithEasing(){
    const data = datasets[currentDataset];
    const len = data.candles.length;
    const index = tick % len;

    easeUpdateChart(candlestickChart, data.candles.slice(0,index+1));
    easeUpdateChart(volumeChart, data.volume.slice(0,index+1));
    easeUpdateChart(trendChart, data.trend.slice(0,index+1));
    easeUpdateChart(heatmapChart, data.heatmap.slice(0,index+1));

    tick++;
    setTimeout(animateWithEasing, speed);
}

// Stop the old animateCharts loop and start easing loop
tick = 0;
animateWithEasing();

// ====================== EXTRA GRADIENT & PARTICLE POLISH ======================

function animatePolishBackground(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Layered gradients
    const gradient = ctx.createRadialGradient(mouse.x||canvas.width/2, mouse.y||canvas.height/2, 50, canvas.width/2, canvas.height/2, canvas.width/2);
    gradient.addColorStop(0,'rgba(255,255,255,0.05)');
    gradient.addColorStop(0.5,'rgba(0,255,255,0.05)');
    gradient.addColorStop(1,'rgba(255,0,255,0.05)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Main particles
    particles.forEach(p=>{
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);
        ctx.fillStyle=p.color;
        ctx.fill();
        p.x+=p.dx; p.y+=p.dy;
        if(p.x<0||p.x>canvas.width)p.dx*=-1;
        if(p.y<0||p.y>canvas.height)p.dy*=-1;
    });

    // Extra particles
    extraParticles.forEach(p=>{
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);
        ctx.fillStyle=p.color;
        ctx.fill();
        if(mouse.x && mouse.y){
            p.x+=(mouse.x-p.x)*0.002; p.y+=(mouse.y-p.y)*0.002;
        }
        p.x+=p.dx; p.y+=p.dy;
        if(p.x<0||p.x>canvas.width)p.dx*=-1;
        if(p.y<0||p.y>canvas.height)p.dy*=-1;
    });

    requestAnimationFrame(animatePolishBackground);
}
animatePolishBackground();
</script>
